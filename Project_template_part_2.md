Это шаблон для решения **второй части** проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

Все задания в этой части проектной работы — дополнительные. Их можно сделать по желанию. Чтобы ревьюер быстрее проверил ваше решение, укажите, какие задания вы сделали. Для этого оставьте нужный эмодзи около заголовка задания:

✅ — вы выполнили это задание.

# Разработка MVP

# ✅ Задание 1. Создание и документирование API

Опишем по 3 эндпоинта для сервиса `Monitoring & Telemetry Service` и `Home Management Service`

### **1. Monitoring & Telemetry Service**

##### Выбор API:
1. Получение текущей телеметрии устройства (RESTful API).
2. Загрузка исторических данных телеметрии (RESTful API).
3. Публикация новых данных телеметрии в Kafka (AsyncAPI).

- **RESTful API**:
   - Используется для операций, где требуется синхронное взаимодействие: запрос текущих или исторических данных телеметрии.
   - RESTful подход удобен, так как позволяет клиенту делать запросы с конкретными параметрами и сразу получать ответ с необходимыми данными.
   - Применение:
      - Получение текущей телеметрии (`GET`).
      - Загрузка исторических данных телеметрии (`POST`).

- **AsyncAPI**:
   - Используется для асинхронной передачи данных в реальном времени, таких как публикация новых данных телеметрии через Kafka.
   - Это позволяет обрабатывать события от множества устройств и уведомлять подписчиков о новых данных без задержек.
  
#### **2. Home Management Service**

##### Выбор API:
1. Управление освещением (включение/выключение) (RESTful API).
2. Управление отоплением (установка температуры) (RESTful API).
3. Подписка на события статусов устройств (AsyncAPI).

- **RESTful API**:
   - Подходит для управления устройствами, где необходимо мгновенно отправить команду и получить результат.
   - RESTful подход используется для операций с состоянием устройства, таких как включение освещения или установка температуры.
   - Применение:
      - Управление освещением (`POST`).
      - Настройка температуры отопления (`POST`).

- **AsyncAPI**:
   - Оправдан для уведомлений об изменении статусов устройств. Это позволяет клиентам получать обновления в реальном времени, например, об открытии ворот или изменении яркости света.
   - Использование Kafka обеспечивает высокую производительность и масштабируемость при обработке событий.

### 2. Документация API

[OpenAPI сервиса мониторинга и телеметрии](docs/api/monitoringService/restful.yaml)

[AsyncAPI сервиса мониторинга и телеметрии](docs/api/monitoringService/async.yaml)

[OpenAPI сервиса управления домом](docs/api/homeService/restful.yaml)

[AsyncAPI сервиса управления домом](docs/api/homeService/async.yaml)

# ✅ Задание 2. Новые микросервисы и интеграция с монолитом

### 1. Язык программирования

Для реализации микросервисной архитектуры в данном проекте выбран язык **C#** и платформа **.NET**. Это обоснование базируется на ряде факторов, связанных с функциональными, производственными и техническими требованиями.

---

### 1. **Широкие возможности платформы .NET**
- **Кросс-платформенность:** Благодаря .NET, приложения можно разрабатывать и запускать на Windows, Linux и macOS, что упрощает интеграцию с различными системами.
- **Масштабируемость:** .NET идеально подходит для построения высоконагруженных и масштабируемых систем. В микросервисной архитектуре каждая служба может эффективно обрабатывать запросы благодаря лёгкости настройки масштабирования.

---

### 2. **Богатая экосистема**
- **Обширные библиотеки:** .NET предоставляет встроенные библиотеки и API для работы с REST, gRPC, WebSocket, а также с асинхронными операциями.
- **Инструменты разработки:** Среда разработки Rider предлагает мощные инструменты для отладки, анализа и тестирования, что ускоряет процесс разработки.
- **Поддержка облачных технологий:** .NET тесно интегрирован с облачными платформами, такими как Microsoft Azure, AWS и Google Cloud, что упрощает развертывание микросервисов.

---

### 3. **Высокая производительность**
- **Оптимизация производительности:** .NET показывает одни из лучших результатов в тестах производительности среди других платформ. Это особенно важно для микросервисов, где требуется минимальная задержка и высокая скорость обработки запросов.
- **Асинхронное программирование:** C# поддерживает асинхронное программирование (async/await), что делает приложения более отзывчивыми, особенно при работе с базами данных или внешними API.

---

### 4. **Поддержка RESTful API**
- **Minimal APIs:** .NET поддерживает простую реализацию REST API с использованием Minimal APIs, что позволяет разработчикам быстро создавать микросервисы с минимальным количеством кода.
- **Документирование через OpenAPI:** Встроенная поддержка Swagger/Swashbuckle упрощает создание интерактивной документации для REST API, что полезно в микросервисной архитектуре.

---

### 5. **Сообщество и поддержка**
- **Большое сообщество:** C# и .NET имеют огромное сообщество разработчиков, которое активно поддерживает начинающих и профессионалов.
- **Поддержка Microsoft:** Регулярные обновления от Microsoft обеспечивают стабильность, безопасность и долгосрочную поддержку платформы.

---

### 6. **Удобство работы с микросервисами**
- **Контейнеризация:** .NET Core поддерживает лёгкое развертывание приложений в Docker-контейнерах.
- **Интеграция с Kafka:** Благодаря библиотеке Confluent.Kafka для .NET, можно легко работать с асинхронными системами обмена сообщениями.

### ✅ 2. Создание проекта

Укажите здесь ссылки на проекты, которые вы создали для микросервисов:

- [Микросервис «Home Management Service»](micro-services-mvp/HomeManagementService)
- [Микросервис «Monitoring & Telemetry Service»](micro-services-mvp/MonitoringService)

### ❌ 3. Интеграция с монолитом

Укажите, какой способ взаимодействия микросервисов с монолитом вы выбрали. Поясните, почему остановились именно на нём.

### ✅ **4. Развёртывание в Docker Compose**

Опишите полную инструкцию для развёртывания с нуля вашего решения, а так же тестовые запросы — Swagger.

1. Убедитесь, что у вас установлен **Docker** и **Docker Compose**.

2. Клонируйте репозиторий и откройте проект:

3. Перейдите в папку с микросервисами:
   ```bash
   cd micro-services-mvp
   ```
   
4. Запустите контейнеры:
   ```bash
   docker-compose up --build
   ```
   
5. Откройте в браузере:
    - **Monitoring Service**: [http://localhost:5009/swagger](http://localhost:5009/swagger)
    - **Home Management Service**: [http://localhost:5010/swagger](http://localhost:5010/swagger)

---

### **Шаг 2: Проверка API**

#### **Monitoring Service**

**1. Получение текущей телеметрии устройства**
1. В Swagger UI для **Monitoring Service** найдите эндпоинт:
   ```
   GET /api/monitoring/{deviceId}/telemetry
   ```
2. Нажмите кнопку **Try it out**.
3. Введите значение для параметра `deviceId`, например:
   ```
   device123
   ```
4. Нажмите **Execute**.
5. Проверьте ответ в секции **Responses**. Ожидаемый результат:
   ```json
   {
     "deviceId": "device123",
     "temperature": 22.5,
     "humidity": 45.2,
     "status": "online",
     "timestamp": "2025-01-12T18:38:40.7401745Z"
   }
   ```

**2. Загрузка исторических данных телеметрии**
1. В Swagger UI найдите эндпоинт:
   ```
   POST /api/monitoring/{deviceId}/history
   ```
2. Нажмите кнопку **Try it out**.
3. Введите значение для параметра `deviceId`, например:
   ```
   device123
   ```
4. В разделе **Request body** укажите тело запроса:
   ```json
   {
     "startDate": "2025-01-01T00:00:00Z",
     "endDate": "2025-01-12T00:00:00Z"
   }
   ```
5. Нажмите **Execute**.
6. Проверьте ответ в секции **Responses**. Ожидаемый результат:
   ```json
   [
     {
       "timestamp": "2025-01-01T00:05:00Z",
       "temperature": 22.0,
       "humidity": 44.0
     },
     {
       "timestamp": "2025-01-01T00:10:00Z",
       "temperature": 22.1,
       "humidity": 44.5
     }
   ]
   ```

**3. Публикация новых данных телеметрии в Kafka**
1. В Swagger UI найдите эндпоинт:
   ```
   POST /api/monitoring/{deviceId}/publishTelemetry
   ```
2. Нажмите кнопку **Try it out**.
3. Введите значение для параметра `deviceId`, например:
   ```
   device123
   ```
4. Нажмите **Execute**.
5. Проверьте ответ в секции **Responses**. Ожидаемый результат:
   ```json
   {
     "status": "Message published to Kafka",
     "telemetryData": {
       "deviceId": "device123",
       "temperature": 22.5,
       "humidity": 45.2,
       "status": "online",
       "timestamp": "2025-01-12T18:38:40.7401745Z"
     }
   }
   ```

#### **Home Management Service**

**4. Управление освещением**
1. В Swagger UI для **Home Management Service** найдите эндпоинт:
   ```
   POST /api/home/lights/{lightId}
   ```
2. Нажмите кнопку **Try it out**.
3. Введите значение для параметра `lightId`, например:
   ```
   light123
   ```
4. В разделе **Request body** укажите тело запроса:
   ```json
   {
     "action": "on",
     "brightness": 80
   }
   ```
5. Нажмите **Execute**.
6. Проверьте ответ в секции **Responses**. Ожидаемый результат:
   ```json
   {
     "lightId": "light123",
     "status": "on",
     "brightness": 80
   }
   ```

**5. Управление отоплением**
1. В Swagger UI найдите эндпоинт:
   ```
   POST /api/home/heating/{zoneId}
   ```
2. Нажмите кнопку **Try it out**.
3. Введите значение для параметра `zoneId`, например:
   ```
   zone1
   ```
4. В разделе **Request body** укажите тело запроса:
   ```json
   {
     "temperature": 22
   }
   ```
5. Нажмите **Execute**.
6. Проверьте ответ в секции **Responses**. Ожидаемый результат:
   ```json
   {
     "zoneId": "zone1",
     "status": "heating",
     "setTemperature": 22
   }
   ```

**6. Подписка на события статусов устройств**
1. В Swagger UI найдите эндпоинт:
   ```
   GET /api/home/consumeUpdates
   ```
2. Нажмите кнопку **Try it out**.
3. Нажмите **Execute**.
4. Проверьте ответ в секции **Responses**. Если сообщения есть, ожидаемый результат:
   ```json
   {
     "receivedUpdates": [
       "{\"deviceId\":\"device123\",\"temperature\":22.5,\"humidity\":45.2,\"status\":\"online\",\"timestamp\":\"2025-01-12T18:38:40.7401745Z\"}"
     ]
   }
   ```
   Если сообщений нет:
   ```json
   {
     "message": "No messages received within the timeout period."
   }
   ```

### **Шаг 3: Завершение тестирования**

1. После завершения тестирования остановите сервисы:
   ```bash
   docker-compose down
   ```

## ❌ **Дополнительная часть**

В ходе работы над заданием вы можете по желанию выполнить ряд условий. Оставьте рядом с описанием условий смайлик, который соответствует статусу решения, и своё пояснение:

- ❌ Реализован паттерн Saga для управления распределенными транзакциями между микросервисами.
- ❌ Разделены операции чтения и записи данных в микросервисах с помощью паттерна CQRS.
- ❌ Применены дополнительные принципы 12-факторных приложений.
- ❌ Использован Kafka кластер для обеспечения отказоустойчивости и масштабируемости.

# ❌ Задание 3. Подготовка 3rd party сервисов для связи микросервисов

1. ❌ **Развёрнут и настроен кластер Kafka.**
Этот пункт задания выполнять необязательно. Это зависит от того, как вы реализовали своё решение. Оставьте рядом с пунктом тот смайлик, который отражает ваш выбор. Если используете кластер Kafka, добавьте сюда ссылку.
2. **Развёрнут и настроен API Gateway**
Поясните, какие технологии для API Gateway вы используете. Оставьте ссылку.
3. **Тестирование**
Поясните, какие команды нужно использовать для тестирования.

# Автоматизация поставки

# ❌ Задание 1. Контейнеризация микросервисов

1. **Созданы Helm-чарты**
2. **Docker-образы собраны и загружены в хранилище артефактов**
Добавьте сюда ссылку на GitHub Container Registry.
3. **Запуск сервисов**
Напишите, какие команды нужно использовать для запуска сервисов с нуля.
4. **Тестирование работы сервисов**
Напишите, какие команды нужно использовать для тестирования.

# ❌ Задание 2. Настройка CI/CD-пайплайнов **c помощью GitHub Actions**

1. **Созданы CI/CD-пайплайны для каждого микросервиса**
    - Опишите шаги пайплайна GitHub Actions в ci.yaml и добавьте сюда ссылку на этот файл.
    - Опишите шаги, которые нужно пройти для сборки, тестирования, загрузки образов в хранилище артефактов и обновления Helm релиза в Minikube.
2. **Настроены триггеры для запуска пайплайнов**

    Пайплайны настроены на запуск при каждом пуше кода в репозиторий.

3. **Проверена работа пайплайнов**

    Пайплайн автоматически запускается и успешно выполняет все этапы: сборка, тестирование, развертывание. Добавьте сюда ссылку, по которой можно посмотреть выполнение пайплайнов.
