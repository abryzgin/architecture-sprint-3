# Задание 1. Анализ и планирование

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании условия задания. Это нормально.

### 1. Описание функциональности монолитного приложения


## Управление отоплением

### Что могут делать пользователи

1. **Получать информацию об отопительной системе**
    - Посмотреть текущие настройки конкретной системы отопления по её идентификатору (эндпоинт `GET /api/heating/{id}`).
2. **Обновлять настройки отопительной системы**
    - Изменять конфигурацию системы отопления (эндпоинт `PUT /api/heating/{id}`).
3. **Включать/выключать отопление**
    - Включать систему отопления (эндпоинт `POST /api/heating/{id}/turn-on`).
    - Выключать систему отопления (эндпоинт `POST /api/heating/{id}/turn-off`).
4. **Устанавливать целевую (желаемую) температуру**
    - Задать температуру, к которой система будет стремиться (эндпоинт `POST /api/heating/{id}/set-temperature`, параметр `temperature`).

### Что поддерживает система

- **Сохранение и чтение данных об отопительных системах**  
  Хранение и управление данными происходит в базе PostgreSQL, к которой обращается приложение (монолит на Java).
- **Синхронное взаимодействие**  
  Все операции по включению/выключению отопления, обновлению настроек и установки целевой температуры выполняются через сервер в синхронном режиме: пользователь вызывает эндпоинт, сервер обрабатывает запрос и отсылает команду устройству.
- **Выезд специалистов для физической установки**  
  На текущий момент пользователи не могут сами добавить в систему новое устройство — необходимо присутствие специалиста для настройки реле и датчиков отопления.

---

## Мониторинг температуры

### Что могут делать пользователи

- **Просматривать текущую температуру**
    - Получать информацию о фактической температуре в доме (эндпоинт `GET /api/heating/{id}/current-temperature`).

### Что поддерживает система

- **Централизованный запрос показаний**  
  Сервер при вызове эндпоинта выполняет запрос к датчику (через сервис `HeatingSystemService`), чтобы получить актуальное значение температуры.
- **Хранение данных о температуре**  
  Сейчас пользователь просто получает текущее значение в ответ на запрос.

---

Таким образом, текущая система предоставляет базовые возможности по управлению отоплением (включение, выключение, изменение настроек, установка целевой температуры) и мониторингу (получение текущей температуры). Все операции выполняются через монолитное Java-приложение, которое взаимодействует с базой PostgreSQL, а доступ к функциональности осуществляется посредством синхронных HTTP-запросов к эндпоинтам контроллера `HeatingSystemController`.

### 2. Анализ архитектуры монолитного приложения

1. **Язык программирования**
    - Приложение написано на Java и развёрнуто в виде монолита.

2. **База данных**
    - Для хранения данных используется реляционная СУБД PostgreSQL.

3. **Характер взаимодействия**
    - Вся логика сосредоточена в одном приложении (монолит).
    - Обмен данными с устройствами (модулями отопления) происходит синхронно: сервер обращается к датчикам/реле по запросу.
    - Пользователи работают с системой через веб-клиент, используя HTTP-эндпоинты (REST).

4. **Отсутствие микросервисной и реактивной архитектуры**
    - В приложении нет выделенных микросервисов, все модули включены в один монолитный код.
    - Нет механизмов асинхронной, реактивной обработки данных: чтение и запись в базу, а также взаимодействие с устройствами идёт в режиме «запрос-ответ».

5. **Текущие возможности масштабирования**
    - Система рассчитана на ограниченное число клиентов (около 100 веб-клиентов) и модулей отопления (около 100).
    - Пользователь не может самостоятельно подключать новое оборудование — для этого необходим выезд и настройка специалиста.

6. **Ограничения для дальнейшего развития**
    - Монолитная архитектура и отсутствие самостоятельного подключения устройств затрудняют быстрый масштаб и развитие функционала (например, подключение новых видов устройств или переход к самообслуживанию).

7. **Развёртывание**
   - Требует остановки всего приложения

Таким образом, нынешнее решение представляет собой единое Java-приложение с единой базой данных и синхронным способом взаимодействия, что сковывает гибкость и усложняет дальнейшее расширение системы.

### 3. Определение доменов и границы контекстов

В текущей версии системы можно выделить несколько ключевых доменов:

1. **Управление отоплением (Heating Management)**
    - Логика включения и выключения отопления.
    - Установка и хранение целевой температуры.
    - Передача команд реле отопительного оборудования.
    - Мониторинг статуса системы (включена/выключена).

2. **Мониторинг температуры (Temperature Monitoring)**
    - Сбор и предоставление данных о текущей температуре.
    - Отражение динамики показаний (если есть функциональность ведения истории).
    - Уведомления или реагирование при отклонении от целевой температуры (в перспективе).

3. **Управление устройствами (Device Management)**
    - Привязка физических устройств (датчики, реле) к системе.
    - Хранение информации об их состоянии и характеристиках.
    - Настройка и обновление прошивок (если предусмотрено).

4. **Управление пользователями и доступом (User & Access Management)**
    - Регистрация, аутентификация и авторизация пользователей в системе.
    - Разграничение прав доступа (администратор, обычный пользователь и пр.).
    - Управление привязкой устройств к конкретным пользователям/другим субъектам.

5. **Установка и обслуживание (Installation & Maintenance)**
    - Процесс физического подключения реле и датчиков на объекте.
    - Настройка и проверка оборудования специалистами компании.
    - Выезды на объект для диагностики и ремонта в случае неисправностей.

На данный момент большая часть этой логики сведена в единое монолитное приложение. В перспективе каждый из перечисленных доменов может быть вынесен в отдельный контекст в рамках перехода к микросервисной архитектуре.

### **4. Проблемы монолитного решения**

1. **Сложность масштабирования**
    - Монолит затрудняет масштабирование отдельных частей системы. Если нагрузка возрастёт (например, резкий рост числа пользователей или подключённых устройств), невозможно быстро и избирательно масштабировать только нужные компоненты.

2. **Трудность внесения изменений**
    - Любое обновление или новая функциональность требуют пересборки и деплоя всего монолита целиком. Это повышает риск регресса (поломки существующих модулей) и увеличивает время вывода новых функций на рынок.

3. **Низкая гибкость при добавлении новых устройств**
    - Пользователи не могут сами подключить новые модули: требуется выезд специалистов. Интеграция новых типов устройств (например, освещение, камеры, замки) усложняется, так как вся логика завязана на монолитном коде.

4. **Отсутствие самообслуживания (SaaS-модель)**
    - Текущая архитектура не предполагает, что пользователь сам настраивает сценарии и модули. Для расширения функциональности или подключения новых датчиков всегда нужен специалист, что противоречит концепции самообслуживания.

5. **Невозможность полноценно использовать асинхронные механизмы**
    - Все операции идут по принципу «запрос-ответ» от сервера к устройству, что может приводить к задержкам при большом количестве запросов или при интеграции новых видов устройств (особенно если они используют события и push-уведомления).

6. **Невозможность быстрых экспериментальных внедрений**
    - В случае, когда нужно добавить экспериментальную функциональность (например, автоматические сценарии на основе событий), приходится дорабатывать монолит, что увеличивает время и риск ошибок.

В совокупности эти проблемы делают текущее монолитное решение неудобным для дальнейшего роста и перехода к полноценной экосистеме умных домов.

### 5. Визуализация контекста системы — диаграмма С4

[диаграмма контекста в модели C4](docs/as_is/Context.puml)

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

Добавьте диаграмму.

**Диаграмма компонентов (Components)**

Добавьте диаграмму для каждого из выделенных микросервисов.

**Диаграмма кода (Code)**

Добавьте одну диаграмму или несколько.

# Задание 3. Разработка ER-диаграммы

Добавьте сюда ER-диаграмму. Она должна отражать ключевые сущности системы, их атрибуты и тип связей между ними.
